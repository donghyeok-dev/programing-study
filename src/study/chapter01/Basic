* 변수(Variables)에 대해 설명해보세요.
-   데이터를 저장할 수 있는 공간에 이름을 붙인 것을 변수라고 부릅니다.
    이 변수가 가르키고 있는 데이터는 integer(정수), floating point unit(부동소수점 수), character(문자), String(문자열)
    등의 자료형(Data Type)으로 구분 될 수 있습니다.

* 자료형(Data Type)이라는게 뭐죠?
- 컴퓨터의 메모리는 모두 0 또는 1로 채워지는데 이를 코드화 한다는 것은 매우 어려운 일입니다.
  이를 돕기 위해 프로그래밍 언어의 컴파일러는 자료형을 제공합니다.

*자료형은 어떤 것들이 있고 크기는 어떻게 되나요?
    ----------------------------------------------------
    byte            1byte           -128 ~ 127
    short           2byte           -32768 ~ 32767
    int             4byte           -2,147,483,648 ~ 2,147,483,647
    long            8byte           -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
    float           4byte           1.4E-45 (-1.4*10^45)~ 3.4028235E38
    double          8byte           4.9E-324 (-4.9*10^324)~ 1.7976931348623157E308
    -----------------------------------------------------

   int는 기본 연산 단위를 사용하는데 16bit = 2byte, 32bit = 4byte, 64bit = 4byte
   long형은 64bit에서 8byte로 확장됨. 16bit = 4byte, 32bit = 4byte, 64bit = 8byte
   float형은 부호 (1bit) + 지수 (8bit) + 가수 (23bit) = 32bit = 4byte
   double형은 부호 (1bit) + 지수 (11bit) + 가수 (52bit) = 64 bit = 8byte

   float 타입은 소수점 아래 9 자리까지만 표현할 수 있는 반면, double 타입은 소수점 아래 18 자리까지도 표현할 수 있습니다.
   고정 소수점 방식보다 표현 범위가 더 넓지만, 부동 소수점으로 표현하는 실수는 항상 오차가 존재하는 단점을 가지고 있습니다.
   즉, 컴퓨터에서 실수를 표현할 때는 정확한 표현이 아닌 근사치를 표현하는 것입니다.(예제 참고)

십진수 0.1은 이진 소수로 정확하게 표현될 수 없습니다.
이진법에서, 1/10은 무한히 반복되는 소수입니다
0.0001100110011001100110011001100110011001100110011...


* 자료구조에 대해서 설명해보세요
자료구조는 데이터를 저장하고 구조화하는 특정한 방법을 말합니다.
일반적으로 배열, 연결리스트, 스택, 큐, 트리, 그래프 등이 있고,
구성요소들을 순자적인 접근하면 선형자료구조이고, 비순차적으로 접근하면 비선형 자료 구조입니다.

*선형 자료 구조와 비선형 자료 구조는 어떤게 있나요?
선형자료 구조는 연결리스트, 스택, 큐
비선형자료 구조는 트리, 그래프

*추상자료형은 무엇인가요?
자료구조와 연산을 결합하여 추상 자료형이라고 부릅니다.
일반적으로 사용되는 추상자료형은 연결 리스트, 스택, 큐, 우선 순위 큐, 이진 트리, 딕셔너리, 분리 집합, 해서 테이블,
그래프 등이 있습니다.

*메모리와 변수
어떤 시스템인지 따라 정수의 바이트 크기는 다를 수 있지만 일반적인 4byte이고, 시작 메모리 주소가 2000이라 가정할 때
변수의 메모리 주소는 2000 ~ 2003이 됩니다.

*포인터가 무엇인가요?
메모리를 가르키는 주소를 참조하는 변수입니다.

*Storage Segments
정적 세그먼트(Static Segment):
    - Code Segment: 프로그램 코드가 저장되고 실행되는 동안 이부분은 읽기 전용으로 생성되고 보호됩니다.
    - Data Segment: 전역변수, 상수 리터럴, 호출 사이에 유지되는 지역변수 등 프로그램 정적 데이터가 저장됩니다. 이 구역은 수정이 가능합니다.
스택 세그먼트(Stack Segment):
    서브루틴, 지역변수, 형식 매개변수, 임시 변수들, 반환 주소
힙 세그먼트(Heap Segment)
    데이터를 동적으로 할당하거나 객체의 크기를 동적으로 조정해야 할 때 사용되는 메모리 영역입니다.
    일반적으로 객체들을 생성하면 힙에 생성됩니다.

단편화(Fragmentation)
    가끔 작은 메모리 블록들이 어떤 프로세스에도 할당되지 않고 낭비되는 현상으로 내부 단편화와 외부 단편화로 구분됩니다.
    - 내부 단편화: 객체를 유지하기 위한 크기보다 큰 크기의 블록이 할당되고 여분의 공간이 사용되지 않을 경우를 말합니다.
    - 외부 단편화: 사용되기엔 충분하지 않는 작은 공간의 블록들이 여러 조각으로 존재하는 현상을 말합니다.

*객체지향 프로그래밍(Object-oriented Programming)
    데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고
    그 객체들 간의 유기적인 상호작용을 통해서 로직을 구현하는 프로그래밍 방법입니다.

    -객체지향 프로그래밍의 특징으로는
        1.캡슐화(Encapsulation): 변수와 메서드를 하나의 클레스라는 캡슐 형태로 만들고 실제 구현 내용을 외부에 감추어 은닉하는 것을 말합니다.
        2.정보은닉(Information Hiding): 캡슐화된 객체에서 접근제어자를 통해 변수나 메서드 접근을 제어하는 것을 말합니다.
                               접근제어자 (Access Modifier)
                                        private: 클래스
                                         내에서만 접근할 수 있음. (변수,메서드)
                                        protected: 동일 패키지 또는 상속관계에서 접근이 가능. (변수,메서드)
                                                    (상속관계이면 다른 패키지 상관없음)
                                        default: 접근제어자를 생략하는 것으로, 동일 패키지 안에서만 접근할 수 있음. (변수,메서드, 클래스)
                                        public: 모든 객체에서 접근 가능함. (변수,메서드, 클래스)

        3.상속: 상위 클래스가 허용하는 범위 내에서 변수, 메서드를 하위 클래스에게 물려 주고 확장하는 방법입니다.
        4.다형성: 하나의 메서드가 다양한 방법으로 재구성 되는 것을 의미하며, 오버라이드와 오버로딩 기법이 있습니다.
               오버라이드(Override): 상속 관계에서 부모의 메서드를 재정의하여 자신만의 구현체를 만들어 사용하는 것입니다.
                                     보통 메서드에 @Override Annotation 을 붙입니다.
                                     (@Override를 안 붙여도 되긴하지만 재정의되었다는 것을 명시적으로 표시하는 것이 좋습니다.)
                                     (리턴타입이나 파라메터는 변경할 수 없습니다.)
               오버로딩(Overloading): 동일한 메서드명이지만 파라메터 타입, 개수가 다른 여러개의 메서드로 정의하는 방법을 말합니다.
                                      (단 파라메터 타입이 동일하고 리턴 타입만 다르게 설정할 수는 없음.)
        5.추상화: 개념이나 표준과 같은 공통된 추상 코드를 작성하고 개별 객체에서 이를 구체화하는 것을 의미합니다.
                   보통 추상코드는 interface나 abstract 클래스로 구성하고 외부에서는 구현체보다는 추상화된 객체를 사용하도록 합니다.
                  (예를들어 페이결제 추상화된 개념이고 네이버페이, 카카오페이, 삼성페이 등은 추상화된 개념을 구체화 시킨 객체입니다.)
    -장점: 상속 기능을 통해 코드를 재사용할 수 있고 많은 기능들을 라이브러리를 통해 가져다 쓸 수 있기 때문에
           절차지향언어보다 생산성이 높습니다.
           그리고 유지보수 측면에서  프로그램의 수정이나 기능 추가 시에 추상화로 다른 코드에 영향을 최소화하고
           객체 모델링을 하기 때문에 수정 해야될 객체들을 좀 더 쉽게 찾아서 수정할 수 있습니다.
           (+ 라이브러리에서 private를 제외한 클래스는 상속도 가능하고 메서드를 재정의할 수도 있음)
           (+ 객체지향언어의 프레임워크가 발달되어서 언어에서 제공하는 라이브러리를 보다 더 많은 기능들이 제공되고 사용할 수 있습니다.)

    -단점: 객체 모델링에 시간이 소요가 되고, 실행속도가 절차지향보다는 상대적으로 느립니다.
        (느린 이유?
                    1. 클래스 단위로 모든 코드를 작성하는 객체지향언어는 관련 기능이 필요할때
                       클래스의 인스턴스를 메모리에 동적할당하고 사용하는 부분이 많기 때문에 절차지향언어보다 상대적으로 느립니다.

                    2. C언어의 경우 컴파일 시 코드를 모두 기계어로 번역해서 바로 메모리에 올려두고 실행하는 반면,
                       Java에서는 바이코드(.class)를 컴파일 한 뒤 동적할당된 코드를 JVM이 번역해서 실행하기 때문에 상대적으로 느립니다.
                       또한 C언어는 동적할당한 메모리를 개발자가 직접 해제하지만, Java는 GC(가비지컬렉터)가 힙영역과 코드 영역을 점유한
                       메모리 공간을 참조하는 레퍼런스가 없으면 메모리 공간을 헤제하는 방식인데 GC도 프로그램이기 때문에 메모리와 연산작업을
                       동반하는 만큼 C언어와 같은 절차지향언어보다 느릴수 밖에 없는 구조입니다.
                       (
                           Java 프로그램 실행과정
                           Java컴파일러(javac)가 소스코드(.java)를 바이트코드(.class)로 컴파일 합니다.
                           그리고 Class Loader를 통해 바이트코드를 JVM으로 로딩시키고
                           Execution engine이 로드된 바이트코드를 해석하고 실행합니다.
                       )

    -객체지향과 절차지향의 개념적 차이점
     절차지향 프로그래밍은 실행순서와 흐름을 먼저 정하고 필요한 자료구조와 기능들을 설계하는 방식이고,
     객체지향 프로그래밍은 자료구조와 기능을 중심으로 모듈들을 먼저 설계한 다음 실행순서와 흐름을 설계하는 방식입니다.

    -객체지향 프로그래밍 원칙(SOLID)

    1. SRP(Single Responsibility Principle) 단일 책임 원칙
        클래스를 구성하는 기능들은 하나의 책임만 가져야 한다는 원칙입니다.
        이는 구현해야될 책임들을 명확하게 분리하여 책임 별로 클래스를 구성해야 된다는 의미입니다.

    2. OCP (Open-closed principle)  개방 폐쇄 원칙
       기존 구성요소는 변경되지 않으면서 기능을 추가할 수 있도록 설계되어야 한다는 원칙입니다.
       이말은 추상화와 다형성를 통해 기존 구성요소는 변경하지 않고
       추가되는 기능을 새로운 구현체로 정의해서 사용할 수 있어야 한다는 의미입니다.

    3. LSP (Liskov substitution principle)  리스코브 치환 원칙
        부모 클래스를 자식 클래스로 대체해도 프로그램의 의미는 변화되지 않는다는 원칙입니다.
        즉 자식 클래스는 부모 클래스가 수행하고 있는 책임을 그대로 수행하면서 추가적인 기능을 제공해야 되는 것입니다.
        예를들어
        동물-사람이라는 상속관계가 있을때 사람이 동물을 대체해도 그 의미는 변하지 않으므로 리스코브 치환원칙을 따르는 것이고,
        아버지-아들이라는 상속관계는 아들이 아버지를 대체할순 없기 때문에 리스코브 치환원칙을 위배한다고 볼 수 있습니다.

    4. ISP (Interface segregation principle)  인터페이스 분리 원칙
        클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 하고,
         인터페이스는 책임에 맞게 분리되어야 한다는 원칙입니다.

    5. DIP(Dependency Inversion Principle) 의존 역전 원칙
         의존 관계를 맺을 때 변화하기 쉬운 것에 의존하기보다는, 변화하지 않는 것에 의존하라는 원칙입니다.
         변하지 않는 인터페이스를 매개로 받고 추상메서드를 통해 기능을 실행하므로서 구현체와의 관계를 느슨하게 만들어야 한다는 의미입니다.
         (변화하지 않는 것은 무엇을 기준으로 구분하면 되는가?
         정책, 개념 같은 추상적인 것은 변하기 어려운 것에 해당하고
         구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것으로 구분하면 좋습니다)

*응집도란 한 프로그램 요소가 얼마나 뭉쳐있는가를 나타내는 척도이고 높을 수록 좋습니다.
*결합도는 프로그램 구성 요소들이 얼마나 의존적인지를 나타내는 척도이고 낮을 수록 좋습니다.

*java8 버전 부터 interface에서 default나
static 메서드에 사용하면, 추상메서드가 아닌 구현체를 가지는 메서드를 정의할 수 있습니다.
인터페이스를 상속 받으면 불필요한 메서드까지 모두 구현해야되는 문제를 해결하고자 추가되었다고 합니다.
public interface DefaultStaticInterface {
public int plus(int i, int j);
default int exec(int i, int j) { return i + j; } //interface를 구현한 구현체의 instance에서 호출할 수 있음.
public static int exe2(int i, int j) { return i + j; } //interface명.exe2(3,4) 형태로 interface에서 직접 접근할 수 있음. (utility성 인터페이스)
}

