* 변수(Variables)
-   데이터를 저장할 수 있는 공간(메모리)에 이름을 붙인 것을 변수라고 부릅니다.

* JAVA 기본 자료형(Data Type)
    ----------------------------------------------------
    byte            1byte           -128 ~ 127
    boolean         1byte          논리형 true or false
    char            2byte           유니코드 0 ~65535('\u0000'~'\uFFFF') 유니코드:영어,숫자-1바이트, 그외 다국어-2바이트
    short           2byte           -32768 ~ 32767
    int             4byte           -2,147,483,648 ~ 2,147,483,647
    long            8byte           -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
    float           4byte           1.4E-45 (-1.4*10^45)~ 3.4028235E38
    double          8byte           4.9E-324 (-4.9*10^324)~ 1.7976931348623157E308
    -----------------------------------------------------

   int는 기본 연산 단위를 사용하는데 16bit = 2byte, 32bit = 4byte, 64bit = 4byte
   long형은 64bit에서 8byte로 확장됨. 16bit = 4byte, 32bit = 4byte, 64bit = 8byte
   float형은 부호 (1bit) + 지수 (8bit) + 가수 (23bit) = 32bit = 4byte
   double형은 부호 (1bit) + 지수 (11bit) + 가수 (52bit) = 64 bit = 8byte

   float 타입은 소수점 아래 9 자리까지만 표현할 수 있는 반면, double 타입은 소수점 아래 18 자리까지도 표현할 수 있습니다.
   고정 소수점 방식보다 표현 범위가 더 넓지만, 부동 소수점으로 표현하는 실수는 항상 오차가 존재하는 단점을 가지고 있습니다.
   즉, 컴퓨터에서 실수를 표현할 때는 정확한 표현이 아닌 근사치를 표현하는 것입니다.

십진수 0.1은 이진 소수로 정확하게 표현될 수 없습니다.
이진법에서, 1/10은 무한히 반복되는 소수입니다
0.0001100110011001100110011001100110011001100110011...

* 자료구조에 대해서 설명해보세요
자료구조는 데이터를 저장하고 구조화하는 특정한 방법을 말합니다.
일반적으로  연결리스트, 스택, 큐, 트리, 그래프 등이 있고,
구성요소들을 순차적으로 접근하면 선형자료구조이고, 비순차적으로 접근하면 비선형 자료 구조라고 합니다.

*선형 자료 구조와 비선형 자료 구조는 어떤게 있나요?
선형자료 구조는 연결리스트, 스택, 큐
비선형자료 구조는 트리, 그래프

*추상자료형은 무엇인가요?
자료구조와 연산을 결합하여 추상 자료형이라고 부릅니다.
일반적으로 사용되는 추상자료형은 연결 리스트, 스택, 큐, 우선 순위 큐, 이진 트리, 딕셔너리, 분리 집합, 해서 테이블,
그래프 등이 있습니다.

*메모리와 변수
어떤 시스템인지 따라 정수의 바이트 크기는 다를 수 있지만 일반적인 4byte이고, 시작 메모리 주소가 2000이라 가정할 때
변수의 메모리 주소는 2000 ~ 2003이 됩니다.

*포인터가 무엇인가요?
메모리를 가르키는 주소를 참조하는 변수입니다.

*Storage Segments
정적 세그먼트(Static Segment):
    - Code Segment: 프로그램 코드가 저장되고 실행되는 동안 읽기 전용으로 보호됩니다.
    - Data Segment: 전역변수, 상수 등 프로그램 정적 데이터가 저장됩니다. (수정 가능)
스택 세그먼트(Stack Segment):
    함수의 주소나 함수에서 사용되는 지역변수나 매개변수가 저장됩니다.
힙 세그먼트(Heap Segment)
    스태틱 변수가 아닌 일반적인 객체를 생성하면 힙에 저장됩니다.

단편화(Fragmentation)
    가끔 작은 메모리 블록들이 어떤 프로세스에도 할당되지 않고 낭비되는 현상으로 내부 단편화와 외부 단편화로 구분됩니다.
    - 내부 단편화: 객체를 유지하기 위한 크기보다 큰 크기의 블록이 할당되고 여분의 공간이 사용되지 않을 경우를 말합니다.
    - 외부 단편화: 사용되기엔 충분하지 않는 작은 공간의 블록들이 여러 조각으로 존재하는 현상을 말합니다.
해결방법: 압축, 통합, 페이징, 메모리풀 등.

*객체지향 프로그래밍(Object-oriented Programming)
    데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고
    그 객체들 간의 유기적인 상호작용을 통해서 로직을 구현하는 프로그래밍 방법입니다.

    -객체지향 프로그래밍의 특징으로는
        1.캡슐화(Encapsulation): 변수와 메서드를 하나의 클레스라는 캡슐 형태로 만들고 실제 구현 내용을 외부에 감추어 은닉하는 것을 말합니다.
        2.정보은닉(Information Hiding): 캡슐화된 객체에서 접근제어자를 통해 변수나 메서드 접근을 제어하는 것을 말합니다.
                               접근제어자 (Access Modifier)
                                        private: 클래스 내에서만 접근할 수 있음. (변수,메서드)
                                        protected: 동일 패키지 또는 상속관계에서 접근이 가능. (변수,메서드)
                                                    (상속관계이면 다른 패키지 상관없음)
                                        default: 접근제어자를 생략하는 것으로, 동일 패키지 안에서만 접근할 수 있음. (변수,메서드, 클래스)
                                        public: 모든 객체에서 접근 가능함. (변수,메서드, 클래스)

        3.상속: 상위 클래스가 허용하는 범위 내에서 변수, 메서드를 하위 클래스에게 물려 주고 확장하는 방법입니다.
        4.다형성: 하나의 메서드가 다양한 방법으로 재구성 되는 것을 의미하며, 오버라이드와 오버로딩 기법이 있습니다.
               오버라이드(Override): 상속 관계에서 부모의 메서드를 재정의하여 자신만의 구현체를 만들어 사용하는 것입니다.
                                     보통 메서드에 @Override Annotation 을 붙입니다.
                                     (@Override를 안 붙여도 되긴하지만 재정의되었다는 것을 명시적으로 표시하는 것이 좋습니다.)
                                     (리턴타입이나 파라메터는 변경할 수 없습니다.)
               오버로딩(Overloading): 동일한 메서드명이지만 파라메터 타입, 개수가 다른 여러개의 메서드로 정의하는 방법을 말합니다.
                                      (단 파라메터 타입이 동일하고 리턴 타입만 다르게 설정할 수는 없음.)
        5.추상화: 개념이나 표준과 같은 공통된 추상 코드를 작성하고 개별 객체에서 이를 구체화하는 것을 의미합니다.
                   보통 추상코드는 interface나 abstract 클래스로 구성하고 외부에서는 구현체보다는 추상화된 객체를 사용하도록 합니다.
                  (예를들어 페이결제 추상화된 개념이고 네이버페이, 카카오페이, 삼성페이 등은 추상화된 개념을 구체화 시킨 객체입니다.)
    -장점: 상속을 통해 코드를 재사용할 수 있어 생산성을 높일 수 있고,
           추상화된 설계로 프로그램 수정 시 다른 코드에 영향을 최소화할 수 있기 때문에 수정
           또한 java의 경우에는 많은 low 레벨의 기능들이 라이브러리로 제공되기 때문에 비지니스 로직에 집중할 수 있는 장점도 있습니다.

           라이브러리로 제공되는 많은 low 레벨의 기능들은?

    -단점: 객체 모델링에 시간이 소요가 되고, 실행속도가 절차지향보다는 상대적으로 느립니다.
        (느린 이유?
                       C언어의 경우 컴파일 시 코드를 모두 기계어로 번역해서 바로 메모리에 올려두고 실행하는 반면,
                       Java에서는 바이코드(.class)로 컴파일하고  클레스로더로 메모리에 로드한 다음
                       JVM에 Execution engine으로 해석해서 실행하기 때문에 상대적으로 느립니다.
                       또한 C언어는 동적할당한 메모리를 개발자가 직접 해제하지만, Java는 GC(가비지컬렉터)가 힙영역과 코드 영역을 점유한
                       메모리 공간을 참조하는 레퍼런스가 없으면 메모리 공간을 헤제하는 방식인데 GC도 프로그램이기 때문에 메모리와 연산작업을
                       동반하는 만큼 C언어와 같은 절차지향언어보다 느릴수 밖에 없는 구조입니다.
                       (
                           Java 프로그램 실행과정
                           Java컴파일러(javac)가 소스코드(.java)를 바이트코드(.class)로 컴파일 합니다.
                           그리고 Class Loader를 통해 바이트코드를 메모리에 로딩시키고
                           JVM이 Execution engine으로 로드된 바이트코드를 해석하고(JIT) 실행합니다.

                           *Execution Engine
                           Interpreter 방식과 JIT(Just-In-time) 컴파일러를 이용하는 방식이 있는데,
                           Interpreter방식은 Row 단위로 바이트코드를 해석하여 실행 가능한 native코드로 만드는 방식이고,
                           JIT(Just-In-time) 컴파일러는 Interpreter가 해석한 native코드를 캐싱하고 있다가 중복된 해석 작업이 발생하면 캐시된 native코드로 대체하는 방식입니다.

                           바이트 코드는 JVM 에 있는 인터프리터를 통해서 읽혀지면서 JVM 이 동작하고 있는 머신에서
                           실행 가능한 native 코드로 변환되어 수행된다. 이 때 특정 영역의 코드가 자주 읽히게 되면
                           그 영역을 hot code 영역이라고 부른다. JIT 컴파일러는 이 hot code 영역을 좀 더 효율적으로 다루기 위해 등장한 컴파일러다.
                           인터프리터가 바이트 코드를 읽던 도중 어떤 영역을 hot code 영역이라고 판단하면 JIT 컴파일러에게 컴파일 요청을한다.
                           JIT 컴파일러는 이 요청을 받고 바이트 코드를 최적화해서 native 코드로 컴파일 한다.
                           이렇게 만들어진 native 코드는 이후 같은 hot code 영역을 읽으려 할 때 인터프리터를 사용하지 않고
                           최적화된 native 코드를 수행할 수 있도록 한다.
                       )

    -객체지향과 절차지향의 개념적 차이점
     절차지향 프로그래밍은 실행순서와 흐름을 먼저 정하고 필요한 자료구조와 기능들을 설계하는 방식이고,
     객체지향 프로그래밍은 자료구조와 기능을 중심으로 모듈들을 먼저 설계한 다음 실행순서와 흐름을 설계하는 방식입니다.

    -객체지향 프로그래밍 원칙(SOLID)

    1. SRP(Single Responsibility Principle) 단일 책임 원칙
        클래스를 구성하는 기능들은 하나의 책임만 가져야 한다는 원칙입니다.
        이는 구현해야될 책임들을 명확하게 분리하여 책임 별로 클래스를 구성해야 된다는 의미입니다.

    2. OCP (Open-closed principle)  개방 폐쇄 원칙
       기존 구성요소는 변경되지 않으면서 기능을 추가할 수 있도록 설계되어야 한다는 원칙입니다.
       이말은 추상화와 다형성를 통해 기존 구성요소는 변경하지 않고
       추가되는 기능을 새로운 구현체로 정의해서 사용할 수 있어야 한다는 의미입니다.

    3. LSP (Liskov substitution principle)  리스코브 치환 원칙
        부모 클래스를 자식 클래스로 대체해도 프로그램의 의미는 변화되지 않는다는 원칙입니다.
        즉 자식 클래스는 부모 클래스가 수행하고 있는 책임을 그대로 수행하면서 추가적인 기능을 제공해야 되는 것입니다.
        예를들어
        동물-사람이라는 상속관계가 있을때 사람이 동물을 대체해도 그 의미는 변하지 않지만,
        아버지-아들이라는 상속관계는 아들이 아버지를 대체할순 없기 때문에 리스코브 치환원칙을 위배한다고 볼 수 있습니다.

    4. ISP (Interface segregation principle)  인터페이스 분리 원칙
        클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 하고,
         인터페이스는 책임에 맞게 분리되어야 한다는 원칙입니다.

    5. DIP(Dependency Inversion Principle) 의존 역전 원칙
         의존 관계를 맺을 때 변화하기 쉬운 것에 의존하기보다는, 변화하지 않는 것에 의존하라는 원칙입니다.
         변하지 않는 인터페이스를 매개로 받고 추상메서드를 통해 기능을 실행하므로서 구현체와의 관계를 느슨하게 만들어야 한다는 의미입니다.
         (변화하지 않는 것은 무엇을 기준으로 구분하면 되는가?
         정책, 개념 같은 추상적인 것은 변하기 어려운 것에 해당하고
         구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것으로 구분하면 좋습니다)

*응집도란 프로그램의 어떠한 기능 또는 요소가 얼마나 뭉쳐있는가를 나타내는 척도이고 높을 수록 좋습니다.
*결합도는 프로그램의 구성 요소들이 얼마나 서로 의존적인지를 나타내는 척도이고 낮을 수록 좋습니다.

*Java는 다중상속(extends class)을 지원하지 않고, 다중 구현(implements interface, interface...)은 지원합니다.
*Java는 포인터를 지원하지 않습니다.
*Java는 소멸자가 없고 사용되지 않는 메모리는 GC에 의해 운영체제로 반환됩니다.

*옅은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점은 무엇인가요?
옅은 복사(Shallow Copy)는 객체의 참조값을 복사하고 깊은 복사는 객체의 실제 값을 복사합니다.

*Interface와 Abstract Class(추상 클래스)의 차이점
- 추상 클래스는 불완전한 클래스로 공통적으로 수행되어야할 기능을 구현하고, 추상적인 기능은 상속 받는 클래스에서 구현하도록 합니다.
  인터페이스는 함수의 구현(implements)을 강제하여 구현 객체들이 동일한 동작을 한다는 것을 보장하기 위함입니다.
- interface는 private, protected 접근제어자를 사용할 수 없지만 다중 구현이 가능하고,
  추상클래스는 모든 접근제어자를 사용할 순 있지만 하나만 확장 가능합니다.
- 추상클래스는 말그래도 클레스이기 때문에 스프링에서 @Controller 등의 Bean으로 만들수 있고 Service를 DI받을 수도 있습니다.
   인터페이스는 이런한 것들이 안되는 차이점 이 있습니다.

*그럼 언제 Interface를 써야하고 언제 추상 클래스를 사용해야 하나요?
- 예를들어 움직인다라는것은 동물, 자동차 뿐만 아니라 강풍으로 어떠한 사물이 움직인다라고 표현할 수 도 있고,
  여러가지 의미로 사용되는 추상적인 개념입니다. 이는 결코 변하지 않으면서 다양한 곳에서 사용할 수 있기 때문에 인터페이스로 적합합니다.
  추상클래스는 핸드폰, 컴퓨터와 같은 좀 더 구체적인 추상적인 개념에 사용됩니다.
  핸드폰의 경우에는 전화걸기, 문자보내기, 사진촬영 등의 공통적 기능들을 가지고 있고 이를 추상 메서드로 정의하여 상속 받은
  아이폰, 안드로이드 객체에서 추상메서드를 각 OS에 맞게 구현하도록 하는 구조에서 사용하면 좋습니다.

  *java8 버전 부터 interface에서 default나
  static 메서드에 사용하면, 추상메서드가 아닌 구현체를 가지는 메서드를 정의할 수 있습니다.
  인터페이스를 상속 받으면 불필요한 메서드까지 모두 구현해야되는 문제를 해결하고자 추가되었다고 합니다.
  public interface DefaultStaticInterface {
  public int plus(int i, int j);
  default int exec(int i, int j) { return i + j; } //interface를 구현한 구현체의 instance에서 호출할 수 있음.
  public static int exe2(int i, int j) { return i + j; } //interface명.exe2(3,4) 형태로 interface에서 직접 접근할 수 있음. (utility성 인터페이스)
  }

- 단항연산자 : 피 연산자가 1개인 연산자
    ~ : 1의 보수
    ! : Not
    ++ : 증감
    -- : 감소
- 이항 연산자 : 피 연산자가 2개인 연산자
- 삼항 연산자 : 피 연산자가 3개인 연산자

|(OR연산자), &(AND연산자), ^(XOR연산자)
A   B   AND    OR    XOR
0   0    0      0     0
0   1    0      1     1
1   0    0      1     1
1   1    1      1     0


*ArrayList와 Vector 차이점
Vector는 ArrayList와 동일한 내부구조를 가지고 있고, Vector는 동기화된 메소드로 구성되어 있기 때문에
멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있습니다.
그래서 멀티 스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있습니다.
스레드 안전 구현이 필요하지 않은 경우 벡터 대신 ArrayList를 사용하는 것이 좋습니다.
Arraylist는 기본적인 기능은 벡터와 동일하나 자동 동기화 기능이 빠져있고, 동기화 옵션이 존재합니다.
그리고 벡터에 비해 속도가 더 빠르기 때문에 벡터에 비해 많이 쓰이고 있습니다

*HashMap에 대해 설명해보세요
HashMap은 Map 인터페이스를 구현한 AbstractMap 추상클레스를 상속받았으며, key와 value를 저장하는 Java Collections 중 하나입니다.
put(), get() 메서드를 사용해 데이터를 추가하거나 조회 하는데,
put()메서드로 데이터를 저장할 때는 내부적으로 키 값을 해싱하여 그 값으로 저장할 버킷 위치를 계산(식별) 합니다.
이처럼 hashing을 사용하기 때문에 많은 양의 데이터를 검색하는 데 뛰어난 성능을 보입니다.
(해시함수를 이용해서 어떤 특정한 값으로 변환시키는 작업을 해싱이라고 합니다.)

그외 특징으로는 동기화가 되지 않고 null을 허용하고 순서를 보장하지 않습니다.

동일하지 않은 어떤 객체 X와 Y가 있을 때, 즉 X.equals(Y)가 '거짓'일 때 X.hashCode() != Y.hashCode()가 같지 않다면, 이때 사용하는 해시 함수는 완전한 해시 함수(perfect hash functions)라고 한다
Boolean같이 서로 구별되는 객체의 종류가 적거나, Integer, Long, Double 같은 Number 객체는 객체가 나타내려는 값 자체를 해시 값으로 사용할 수 있기 때문에 완전한 해시 함수 대상으로 삼을 수 있다.
하지만 String이나 POJO(plain old java object)에 대하여 완전한 해시 함수를 제작하는 것은 사실상 불가능하다.
HashMap은 기본적으로 각 객체의 hashCode() 메서드가 반환하는 int형 값을 사용하는 데,
32비트 정수 자료형으로는 완전한 자료 해시 함수를 만들 수 없다.
논리적으로 생성 가능한 객체의 수가 2^32보다 많을 수 있기 때문이며,
또한 모든 HashMap 객체에서 O(1)을 보장하기 위해 랜덤 접근이 가능하게 하려면 원소가 2^32인 배열을 모든 HashMap이 가지고 있어야 하기 때문이다.
HashMap는 메모리를 절약하기 위하여 실제 해시 함수의 표현 정수 범위 |N|보다 작은 M개의 원소가 있는 배열만을 사용한다.
int index = X.hashCode() % M;
이 코드와 같은 방식을 사용하면, 서로 다른 해시 코드를 가지는 서로 다른 객체가 1/M의 확률로 같은 해시 버킷을 사용하게 된다.

해쉬 충돌(hash collision)을 해결하기 위한 자료구조로 Open Addressing, Separate Chaining가 있는데
Open Addressing은 데이터를 삽입하려고 할때 해시 버킷이 사용중이라면 다른 해시 버킷에 해당 데이터를 삽입하는 방식이고
데이터 개수가 적으면 Separate Chaining 방식 보다 성능이좋지만 데이터 개수가 많아질 수록 캐시 적중률이 낮아지기 때문에 성능이 떨어진다.

Java 2부터 Java 7까지의 HashMap에서 사용하는 Separate Chaining은 중복 해시 버킷이 발생하면 링크드 리스트 노드를 추가하여
데이터를 삽입 합니다. Java 8에서는 노드가 8개 이하일 경우에는 Linked List를 사용하고 8개 이상으로 늘어날때는
Tree 구조를 사용함으로서 성능을 향상 시켰습니다.
HashTable, HashMap, LinkedHashMap, SortedMap, TreeMap 등 존재


*HashTable과 HashMap 차이
- Hashtable은 Thread-Safe O, null X, O(1) 시간복잡도
- HashMap은   Thread-Safe X, null O, 순서보장 x, O(1) 시간복잡도
- HashMap보다는 느리다 하지만 동기화된 HashMap 보다는 빠르다. //Map m = Collections.synchronizedMap(new `LinkedHashMap`(...));
- Hashtable은 JAVA1과 호환성을 위해 구현체가 거의 변화가 없지만, HashMap은 현재까지도 지속적으로 개선되고 있습니다.

*LinkedHashMap과 HashMap은
- Thread-Safe X, null x, 순서보장 O
- HashMap과 동일하게 put() 직전에 contain()을 호출하여 내부에 같은 key가 존재한다면
  새로 들어가는게 아니라 기존에 있던 key에 value 값이 업데이트 된다.
- O(1)의 시간 복잡도를 갖는다.
- double-linked List로 모든 Entry를 유지한다.

*TreeMap
- 이진트리를 기반으로 한 Map 컬렉션입니다
- TreeSet과의 차이점은 TreeSet은 그냥 값만 저장한다면 TreeMap은 키와 값을 저장한다는 점입니다.
- 키는 저장과 동시에 오름차순으로 정렬됨.(숫자일 경우 값, 문자열 경우 유니코드로 정렬)
- TreeMap은 일반적으로 Map으로써의 성능이 HashMap보다 떨어집니다. 그 이유는 데이터를 저장할 때 즉시 정렬하기에
  추가나 삭제가 HashMap보다 오래 걸립니다.
- 정렬된 상태로 Map을 유지해야 하거나 정렬된 데이터를 조회해야 하는 범위 검색이 필요한 경우 TreeMap을 사용하는 것이 효율성면에서 좋습니다.
- 입력 순서 보장하지 않으며, 정렬된 순서로 저장되어 출력됨
  검색기능 O(log(n)) 시간복잡도, Red Black Tree 자료구조로 이루어짐
- null Key 허용 안함 ( Null Pointer Exception 발생)


*Stack
- LIFO(Last In First Out), 후입선출
- push(넣고) pop(꺼내고)
- push, pop이 발생하는 top이라는 입출구가 있고 바닥을 bottom이라 한다.
- Vector를 상속 받음.
- 인터럽트처리, 수식의 계산, 서브루틴의 복귀 번지 저장 등에 쓰임
- 그래프의 깊이 우선 탐색(DFS)에서 사용
- 재귀적(Recursion) 함수를 호출 할 때 사용

*Queue
- FIFO(First In First Out), 선입선출
- offer(넣고) poll(꺼내고)
- 버퍼로 자주 이용하는 자료구조
- Collection를 상속 받은 interface이고 LinkedList와 PriorityQueue 구현체 클래스가 존재한다.
- LinkedList는 Queue의 구현체 클래스로 사용되기도 하지만 List interface의 구현제로도 사용된다.

*우선순위 큐(Priority Queue)
우선순위 큐(Priority Queue)는 말그대로 큐의 성질을 가지면서 각 데이터가 우선순위를 가지고 있어서
높은 순서대로 나오게 해주는 큐입니다. 만약 동일한 우선순위라면 큐에서의 위치 순으로 처리 됩니다.
만약 어떤 객체의 내부 속성에 대해 특별한 기준으로 정렬을 하고 싶다면 COmparable 인터페이스의 compareTo 메소드를 구현하면 됩니다.

*ArrayList와 LinkedList 차이점.
- ArrayList는 검색이 빈번하며 Thread-safe 하지 않는 곳에서 사용하고,
  LinkedList는 삭제/삽입이 빈번하고 검색이 필요 없는 곳에서 사용합니다.

- ArrayList는 사이즈가 고정되어 있고, 사이즈를 초과하면 사이즈를 늘려주는 연산이 추가되어야하고,
삭제 시에는 순차적인 인데스 구조로 인해 삭제된 빈 인덱스를 채워야 하기 때문에 연산 작업이 추가됩니다.
따라서 ArrayList는 사이즈의 범위를 예상할 수 있고, 삭제/삽입이 빈번하지 않은 곳에서 사용해야 합니다.
그리고 LinkedList는 삭제/삽입 과정에서 ArrayList 처럼 추가 연산 없이 주소만 연결 시켜주기 때문에
ArrayList보다 빠릅니다.

ArrayList는 각 객체에 무작위 접근이 가능하지만 LinkedList는 순차접근만 가능합니다.
또한 ArrayList는 메모리에 연속적인 묶음으로 저장하는 반면, LinkedList는 자료들을 불연속적인 단위로 저장합니다.
참조의 지역성 면에서 ArrayList가 유리합니다.
따라서 자료를 검색하는 곳에서는 LinkedList보다는 ArrayList를 사용하는 것이 좋습니다.

LinkedList는 다음 노드에 대한 포인트 정보를 각 노드마다 포함하고 있기 때문에 ArrayList보다 더 많이 공간이 필요합니다.

(LinkedList는 AbstractSequentialList를 상속 받고 있고, ArrayList는 RandomAccess interface를 구현하고 있습니다.)
(참조의 지역성는 한번 참조된 데이터는 다시 참조될 가능성이 높고 참조된 주변 데이터 역시 같이 참조될 가능성이 높다는 이론입니다.)

*동기화
멀티 스레드에서 Heap영역의 객체를 동시에 사용할 때 발생할 수 있는 문제를 방지하기 위한 방법입니다.

- 공유 자원의 상호 배타적인 접근을 보장하고 데이터 경합을 방지하는 잠금을 제공함.
- static synchronized 메서드, synchronized 메서드, synchronized 블럭을 사용할 수 있음.
- synchronized 메서드는 해당 메서드가 포함된 클래스도 잠금 상태가 되므로 주의해서 사용해야 한다.
- 스레드가 synchronized 메서드 또는 블럭에 진입할때 객체(Object) 레벨의 잠금을 획득하고
   static synchronized 메서드는 클래스 레벨의 잠금을 획득합니다. 이후 메서드가 완료되거나 예외가 발생하면 잠금이 해제됩니다.
- 동기화는 성능 문제를 동반하기 때문에 반드시 필요한 부분에만 사용해야 함.
- synchronzied 외 Atomic, volatile을 사용하는 방법도 있음.

*String, StringBuilder, StringBuffer
- String: 불변(immutable)의 속성의 문자열를 참조하기 때문에 문자열을 수정하거나 합치는 작업을 수행하면 그 결과값에 대한 새로운
          문자열을 참조합니다. 이처럼 String은 추가, 수정 등의 연산이 빈번하게 발생하면 Heap 메모리에 많은 가비지를 생성하게 되므로
          성능상 좋지 않습니다.
          String은 Thread-Safe합니다.

- String str = "hello"; 라고 문자열의 값을 명시한 경우 JVM에는 이 값을 String Pool에 넣어 관리합니다.
  이후 String str2 = "hello"; 라고 동일한 값을 사용할 경우 문자열을 생성하지 않고 String Pool에 참조값만 가져와 사용합니다.

- StringBuffer, StringBuilder: 가변성을 가지며  .append(), .delete() 등의 메서드를 이용하여 동일한 메모리 객체 내에서
          문자열을 변경할 수 있습니다. 따라서 문자열을 변경작업을 해야할 때는 String 대신 StringBuffer나 StringBuilder를 사용해야 합니다.

- StringBuffer는 Thread-Safe이고, StringBuilder는 Thread-Safe하지 않기 때문에 멀티 쓰레드 환경에서는 StringBuffer를 사용해야하고,
  그렇치 않다면 StringBuilder가 더 빠르기 때문에 StringBuilder를 사용해야 합니다.

* 프로세스와 스레드
   하나의 프로세에는 여러 개의 스레드가 생성될 수 있으므로 1:N관계를 가지며 LWP(Light Weight Process)라고도 합니다.
