기한을 맞추려고 나쁜 코드를 양산하려는 습관이 있는데, 사실 기한을 맞추기 위한 방법은 코드를 최대한 깨끗하게 유지하는 습관이다.
깨끗한 코드를 어떻게 작성할것인가?
좋은 코드와 나쁜 코드를 구분하고 나쁜 코드를 좋은 코드로 바꾸는 코드 감각이 필요하다.

비야네 스트롭스트룹, c++창시자
- 논리가 심플하고 의존성을 최대한 줄여야 유지보수가 쉬워진다.
- 창문이 깨진 건물은 창문이 더 깨져도 상관하지 않는다. 즉 나쁜 코드는 더 나쁜 코드를 양산할 수 있다라는 뜻.
- 오류 처리를 철저하게 해야 된다.

그래디 부치
- 명쾌한 추상화와 단순한 제어문을 사용해야 된다.
- 가독성 좋은 코드를 작성해라.

큰 데이브 토마스
- 단위테스트 케이스와 인수 테스트 케이스를 작성해라.
- 의존성은 최소화하며 각 의존성을 명확히 정의한다.
- 고치기 쉬운코드를 작성해라.

마이클 페더스
- 세세한 사항까지 꼼꼼하게 신경쓴 코드를 작성해라.

론 제프리스
- 테스트 코드를 통한 리팩토링
- 함수나 변수에 의미 있는 이름 짓기
- 초기부터 추상화 고려하기

보이스카우트 규칙
- 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라
- 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.

프리퀄과 원칙
- SRP, OCP, DIP 등의 PPP(프리퀄) 책에서 표명한 설계 원칙을 준수해라.

*의도가 분명하게 이름 지어라.
1. 파라메터로 넘어 온 변수는 무엇이 들어 있는지 알수 없기 때문에 매개변수 이름에 표현해야된다.
2. 배열 또는 Collection에 담긴 값들이 무엇이며, 어떤 의미인지 나타내는 변수명으로 표현해야 된다.
3. 매직넘버(숫자 하드코딩)나 매직 리터럴(문자열 하드코딩)을 사용하지말고 상수로 선언하여 의미 있는 이름으로 사용하자.
4. 메서드의 리턴되는 변수가 어떤 의미의 값인지를 표현하자.
5. 의미 있는 값들의 집합은 클래스나 배열로 사용하자
6. 사용자 리스트를 표현하는 변수명은 userList 보단 users라고 표현하자. List는 컬렉션명과 혼동될 수 있다.
7. 비슷한 클래스나 메서드명을 여러개 만들지 말자.
8. 숫자와 비슷한 알파벳 소문자 l이나 O 등은 변수로 사용하지 말자. (예 int a = l; )
9. 불용어 info, data, a, an, the, variable, string 등을 사용하지 말자. productInfo, productData, nameString 같은 것들 말이다.
10. 발음하기 쉬운 이름을 사용해라. 예를들어 gencmpnycd와 같은 복합 줄임말은 발음하기가 어렵다.
11. 변수명에 타입명을 포함하게 되면 타입을 변경했을때 변수명을 함께 변경 해주어야 한다.
12. 접두어 등으로 변수명을 만들지말고 카멜케이스 방식을 사용하는 것이 좋다.
13. 클래스나 인터페이스명에 굳이 'I' 등과 같은 접두어를 붙이지말자. 예(IShopFactory -> ShopFactory)
14. 변수를 자신만이 아는 이름으로 사용하지 말자. 예 URL을 r이라는 변수로 사용한다던지..
15. 클래스와 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account 등이 좋은 예며,
    Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다.
16. 메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등이 좋은 예이다.
17. 접근자(Accessor), 변경자(Mutator), 조건자(Predicate)는 javabean 표준에 따라 앞에 get, set, is를 붙인다.
18. 생성자(Constructor)를 중복정의(Overload)할 때는 정적 팩토리 메서드를 사용하고, 생성자 사용을 제한하려면 private로 선언한다.
    Complex complex = Complex.FromNumber(7);
19. 특정 국가, 문화에서만 이해할 수 있는 단어는 피해야 한다. 예를들어 kill 대신 whack라는 표현과 같은..
20. 일관성있는 추상적 개념을 사용해라. 예를들어 어떤 클래스에서는 setUser을 사용하고 어떤 클래스에서는 updateUser를 사용한다면 혼란스럽다.
21. 한 단어로 두가지 목적으로 사용하지마라. 한 개념에는 한 단어를 사용하라.
22. 의미 있는 데이터는 클래스로 묶어 사용하고 클래스로 사용하기 힘들다면 의미있는 접두어를 사용하자.
    예 addrFirstName, addrLastName, addrState
23. 불필요한 맥락을 없애라. 포인트 관련 애플리케이션을 개발한다고 하여 주요 클래스 앞에 PointAccount형식에 이름을 붙이는 건 올바르지 않다.

*함수를 이해하기 쉽게 만들어라
1. 최대한 작게 만들어라
2. 함수에 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.
3. 함수내에서는 한가지만 잘 처리하도록 하자. 함수 내 의미 있는 이름으로 추출할 수 있는 작업이 없는 상태가 한가지 작업을 한다고 할 수 있다.
4. 함수내 추상화 수준은 동일하게 한다. parser.render(path), getHtml(), .append("\n")와 같이 추상화 수준이 섞이지 않도록 한다.
5. 클래스내 함수의 배치는 위에서 부터 추상화 수준이 높은 순으로 배치하고 내려갈 수록 추상화 수준이 낮은 순으로 배치하는 것이 좋다.
6. 함수 내에서 특정 파라메터 값을 if 또는 switch문으로 분기하여 여러 작업을 처리하는 것은 좋지 않다.
   보통 이렇게 처리하게 되면 함수의 코드 길이가 길어지고, 한가지 함수에 여러 작업을 처리하므로 SRP 원칙을 위배하며,
   특정 파라메터에 종속되므로 OCP 원칙에 위배될 수 있다.
   따라서 이렇게 특정 파라메터의 따른 조건문으로 분기 처리를 하고 싶을때는 추상 팩토리(abstract factory) 방식으로 처리한다.

   public abstract class Employee {
       public abstract boolean isPayday();
       public abstract Money calculatePay();
       public abstract void deliverPay();
   }

   public interface EmployeeFactory {
       public Employee(EmployeeRecord r) throws InvalidEmployeeType;
   }

   public class EmployeeFactoryImpl implements EmployeeFactory {
       public Employee(EmployeeRecord r) throws InvalidEmployeeType {
           switch(r.getType()) {
               case COMMISSIONED:
                   return new CommissionedEmployee(r);
               case HOURLY:
                   return new HourlyEmployee(r);
               default:
                   throw new InvalidEmployeeType(r.getType());
           }
       }
   }

7. 서술적인 이름을 사용하라. 짧고 어려운 이름보단 길고 서술적인 이름이 이해하기 쉽다.
8. 함수에서 인수는 3개이상 사용하지마라. 0개(무항) > 1개 > 2개로 좋으며, 3개는 가능한 피하는 것이 좋으며 4개부터는 사용하지마라.
   - 코드를 읽는 사람의 가독성을 떨어트리고 테스트 케이스 작성을 힘들게 함.
9. Setter를 제외하고 함수의 인수로 부울 값을 넘기지 말자. 함수가 한번에 여러가지 처리를 한다는 의미이므로 좋지 않기 때문.
10. 2항함수는 단항함수보다 이해하기 어렵지만 Point p = new Point(0,0)과 같이 적절한 경우도 있다.
11. 좋은 함수명은 동사/명사를 조합하는 것이 좋다. 항의 수에 따라 이름을 정한다.
    예) 단항의 경우 void writeField(String field)
    예) 2항인 경우 void assertExpectedEqualsActual
    (expected, actual)






